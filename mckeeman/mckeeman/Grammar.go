package mckeeman_mckeeman

import mk "parsium/mckeeman"

func Grammar() mk.Grammar {
	return mk.NewGrammar([]mk.Rule{
		mk.NewRule(
			mk.NewName("grammar"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("rules"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("space"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewSingleton(0x0020),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("newline"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewSingleton(0x000A),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("name"),
			// TODO Order
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("letter"),
					mk.NewName("name"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("letter"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("letter"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewRange('a', 'z'),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewRange('A', 'Z'),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewSingleton('_'),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("indentation"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("space"),
					mk.NewName("space"),
					mk.NewName("space"),
					mk.NewName("space"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("rules"),
			// TODO Order
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("rule"),
					mk.NewName("newline"),
					mk.NewName("rules"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("rule"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("rule"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("name"),
					mk.NewName("newline"),
					mk.NewName("alternatives"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("nothing"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("nothing"),
			// TODO Order
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("indentation"),
					mk.NewSingleton('"'),
					mk.NewSingleton('"'),
					mk.NewName("newline"),
				}),
				mk.EmptyAlternative(),
			},
		),
		mk.NewRule(
			mk.NewName("alternatives"),
			// TODO Order
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("alternative"),
					mk.NewName("alternatives"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("alternative"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("alternative"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("indentation"),
					mk.NewName("items"),
					mk.NewName("newline"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("items"),
			// TODO Order
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("item"),
					mk.NewName("space"),
					mk.NewName("items"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("item"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("item"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("literal"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("name"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("literal"),
			// TODO Order
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("range"),
					mk.NewName("exclude"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("singleton"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewSingleton('"'),
					mk.NewName("characters"),
					mk.NewSingleton('"'),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("singleton"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewSingleton('\''),
					mk.NewName("codepoint"),
					mk.NewSingleton('\''),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("codepoint"),
			// TODO Order
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("hexcode"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewRange(' ', 0x10FFFF),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("hexcode"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewCharacters("10"),
					mk.NewName("hex"),
					mk.NewName("hex"),
					mk.NewName("hex"),
					mk.NewName("hex"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("hex"),
					mk.NewName("hex"),
					mk.NewName("hex"),
					mk.NewName("hex"),
					mk.NewName("hex"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("hex"),
					mk.NewName("hex"),
					mk.NewName("hex"),
					mk.NewName("hex"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("hex"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewRange('0', '9'),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewRange('A', 'F'),
				}),
			},
		),

		mk.NewRule(
			mk.NewName("range"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("singleton"),
					mk.NewName("space"),
					mk.NewSingleton('.'),
					mk.NewName("space"),
					mk.NewName("singleton"),
				}),
			},
		),
		mk.NewRule(
			mk.NewName("exclude"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("space"),
					mk.NewSingleton('-'),
					mk.NewName("space"),
					mk.NewName("singleton"),
					mk.NewName("exclude"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("space"),
					mk.NewSingleton('-'),
					mk.NewName("space"),
					mk.NewName("range"),
					mk.NewName("exclude"),
				}),
				mk.EmptyAlternative(),
			},
		),
		mk.NewRule(
			mk.NewName("characters"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewName("character"),
					mk.NewName("characters"),
				}),
				mk.NewAlternative([]mk.Item{
					mk.NewName("character"),
				}),
				// TODO Doesn't exist but can't parse "" otherwise
				mk.EmptyAlternative(),
			},
		),
		mk.NewRule(
			mk.NewName("character"),
			[]mk.Alternative{
				mk.NewAlternative([]mk.Item{
					mk.NewRangeExclude(
						' ',
						0x10FFFF,
						mk.Exclude{
							Literal: mk.NewSingleton('"'),
							Next:    nil,
						},
					),
				}),
			},
		),
	})
}
